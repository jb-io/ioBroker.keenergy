{
  "version": 3,
  "sources": ["../../src/lib/MaskTreeParser.ts"],
  "sourcesContent": ["'use strict';\n\nimport checkCondition from './conditionChecker';\nimport xpath from 'xpath.js';\nimport { Node, Element } from 'xmldom/lib/dom';\nimport { DOMParser as Dom } from 'xmldom';\nimport globalUtils from './globalUtils';\nimport Keba from './Keba';\n\ntype Context = {\n    placeHolder?: string;\n};\n\ntype ReadWriteVar = {\n    name: string;\n    type: 'text' | 'numeric' | 'enum' | 'bool';\n    writable: boolean;\n    observe?: boolean;\n    attributes?: Record<string, any>;\n    unit?: string;\n    formats?: any;\n};\n\nexport default class MaskTreeParser {\n    private keba: Keba;\n    private _readWriteVars: Record<string, ReadWriteVar> = {};\n    private _varsCache: Record<string, string | number | boolean> = {};\n    private readonly _maxInputLevel: number;\n    private readonly _maxDisplayLevel: number;\n\n    constructor(keba: Keba) {\n        this.keba = keba;\n        this._maxInputLevel = parseInt(globalUtils.config.maxInputLevel);\n        this._maxDisplayLevel = parseInt(globalUtils.config.maxDisplayLevel);\n    }\n\n    private isNumeric(value: string): boolean {\n        return (parseInt(value) + \"\") === value;\n    }\n\n    private parseVar(value: string): string | number | boolean {\n        const valueMap: Record<string, boolean> = {\n            'true': true,\n            'false': false,\n        };\n        if (valueMap[value] !== undefined) {\n            return valueMap[value];\n        }\n        if (this.isNumeric(value)) {\n            return parseInt(value);\n        }\n        return value;\n    }\n\n    private async initCachedVars(visibleVars: Array<string>): Promise<void> {\n        for (const { name, value } of await this.keba.readVars(visibleVars)) {\n            this._varsCache[name] = this.parseVar(value);\n        }\n    }\n\n    private async getCachedVar<T extends string | number | boolean>(variable: string): Promise<T> {\n        if (typeof this._varsCache[variable] === 'undefined') {\n            this._varsCache[variable] = this.parseVar((await this.keba.readVar(variable)).value);\n        }\n        return this._varsCache[variable] as T;\n    }\n\n    private async checkNodeVisible(node: Element, context: Context): Promise<boolean> {\n        if (!node.hasAttribute('visibleVar')) {\n            return true;\n        }\n        const visibleValueExpression = node.hasAttribute('visibleValue') ? node.getAttribute('visibleValue') : null;\n        const visibleVars = this.replacePlaceholder(node.getAttribute('visibleVar')!, context).split(';');\n        for (const visibleVar of visibleVars) {\n            if (!(await this.checkVisibleVarCondition(visibleVar, visibleValueExpression))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private async checkVisibleVarCondition(visibleVar: string, visibleValueExpression: string | null): Promise<boolean> {\n        const value = await this.getCachedVar(visibleVar);\n        return checkCondition(value, visibleValueExpression);\n    }\n\n    private getNodeAttribute(node: Element, attribute: string, defaultValue: string | null = null): string | null {\n        return node.hasAttribute(attribute) ? node.getAttribute(attribute) : defaultValue;\n    }\n\n    private checkNodeDisplayLevel(node: Element): boolean {\n        const displayLevel = this.getNodeAttribute(node, 'displayLevel', '-1');\n        return parseInt(displayLevel!) <= this._maxDisplayLevel;\n    }\n\n    private replacePlaceholder(value: string, context: Context): string {\n        if (typeof context.placeHolder !== 'undefined' && value.match(/\\[\\?]/)) {\n            return value.replace(/\\[\\?]/, `[${context.placeHolder}]`);\n        }\n        return value;\n    }\n\n    private isElementNode(node: Node): boolean {\n        return node.nodeType === Node.ELEMENT_NODE;\n    }\n\n    private async loopChildNodes(node: Element, context: Context): Promise<void> {\n        const childNodes = node.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            const childNode = childNodes[i] as Element;\n            if (this.isElementNode(childNode)) {\n                await this.handleNode(childNode, context);\n            }\n        }\n    }\n\n    private addReadWriteVar(name: string, type: 'text' | 'numeric' | 'enum' | 'bool', writable = false, observe = false): void {\n        this._readWriteVars[name] = {\n            name: name,\n            type: type,\n            writable: writable,\n            observe: observe\n        };\n    }\n\n    private async handleNode(node: Element, context: Context): Promise<void> {\n        if (!this.isElementNode(node)) {\n            return;\n        }\n        if (!this.checkNodeDisplayLevel(node) || !(await this.checkNodeVisible(node, context))) {\n            return;\n        }\n\n        switch (node.nodeName) {\n            case 'genericMask':\n                if (node.hasAttribute('placeHolderVar')) {\n                    const maxPlaceHolder = await this.getCachedVar<number>(node.getAttribute('placeHolderVar')!);\n                    for (let placeHolder = 0; placeHolder < maxPlaceHolder; placeHolder++) {\n                        const subContext: Context = { ...context, placeHolder: `${placeHolder}` };\n                        await this.loopChildNodes(node, subContext);\n                    }\n                } else {\n                    await this.loopChildNodes(node, context);\n                }\n                break;\n            case 'userMask':\n                const maskId = node.getAttribute('maskId')!;\n                if (maskId.match(/^usermasks\\..*LinTab$/)) {\n                    const prefix = this.replacePlaceholder(node.getAttribute('visibleVar')!.split('.').slice(0, -1).join('.'), context);\n                    const varName = prefix + '.linTab.fileName';\n\n                    this.addReadWriteVar(varName, 'text');\n                    const curveName = await this.getCachedVar(varName);\n\n                    const linTabIds = Array.from({ length: 30 }, (_, i) => `APPL.CtrlAppl.sParam.linTabPool[${i}].name`);\n                    const linTabMappings: Record<string, string> = {};\n                    for (const { name, value } of await this.keba.readVars(linTabIds)) {\n                        if (value.length > 0) {\n                            linTabMappings[value] = name.split('.').slice(0, -1).join('.');\n                        }\n                    }\n\n                    const linTabPoolPrefix = linTabMappings[curveName as string];\n                    const noOfPointsVarName = `${linTabPoolPrefix}.noOfPoints`;\n                    const nameVarName = `${linTabPoolPrefix}.name`;\n                    const noOfPoints = await this.getCachedVar<number>(noOfPointsVarName);\n\n                    this.addReadWriteVar(nameVarName, 'text');\n                    this.addReadWriteVar(noOfPointsVarName, 'numeric', true);\n\n                    for (let i = 0; i < noOfPoints; i++) {\n                        for (const suffix of ['x', 'y']) {\n                            this.addReadWriteVar(`${linTabPoolPrefix}.points[${i}].${suffix}`, 'numeric', true);\n                        }\n                    }\n                }\n                break;\n            case 'weektimerMask':\n                const varPath = this.replacePlaceholder(node.getAttribute('varPath')!, context);\n                for (let day = 0; day <= 6; day++) {\n                    for (let time = 0; time <= 2; time++) {\n                        for (const mode of ['start', 'stop']) {\n                            this.addReadWriteVar(`${varPath}.day[${day}].enableTime[${time}].${mode}`, 'numeric', true);\n                        }\n                    }\n                }\n                break;\n            case 'var':\n                let varName = this.replacePlaceholder(node.childNodes[0].nodeValue!, context);\n                this.addReadWriteVar(\n                    varName,\n                    node.getAttribute('type')! as 'text' | 'numeric' | 'enum' | 'bool',\n                    this.getNodeAttribute(node, 'readOnly') === 'false' && parseInt(this.getNodeAttribute(node, 'inputLevel', '-1')!) <= this._maxInputLevel,\n                    this.getNodeAttribute(node, 'observeMsgId') === 'true'\n                );\n                break;\n        }\n    }\n\n    private async enrichWithAttributes(): Promise<void> {\n        const readWriteVars = await this.keba.readVars(Object.keys(this._readWriteVars), true);\n        const units = await this.keba.readAllUnits();\n        const formats = await this.keba.readAllFormats();\n        for (const { name, attributes } of readWriteVars) {\n            const readWriteVar = this._readWriteVars[name];\n            readWriteVar.attributes = attributes;\n\n            if (readWriteVar.attributes && readWriteVar.attributes['unitId'] && units[readWriteVar.attributes['unitId']]) {\n                readWriteVar.unit = units[readWriteVar.attributes['unitId']];\n            }\n            if (readWriteVar.attributes && readWriteVar.attributes['formatId'] && formats[readWriteVar.attributes['formatId']]) {\n                readWriteVar.formats = formats[readWriteVar.attributes['formatId']];\n            }\n        }\n    }\n\n    public async getVarsFromMaskTree(): Promise<Record<string, ReadWriteVar>> {\n        this._readWriteVars = {};\n        this._varsCache = {};\n\n        const maskTreeContent = await this.keba.readMaskTreeGetContent();\n        const doc = new Dom().parseFromString(maskTreeContent);\n\n        const visibleVars = xpath(doc, '/*/genericMask[@visibleVar]/@visibleVar').map((node: any) => node.nodeValue);\n        await this.initCachedVars(visibleVars);\n\n        const nodes = xpath(doc, '/*/genericMask[@visibleVar]');\n        for (const node of nodes) {\n            await this.handleNode(node as Element, {});\n        }\n\n        await this.enrichWithAttributes();\n\n        return this._readWriteVars;\n    }\n}\n"],
  "mappings": "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",
  "names": ["globalUtils", "checkCondition", "varName", "Dom", "xpath"]
}
