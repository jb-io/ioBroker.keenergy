{
  "version": 3,
  "sources": ["../../src/lib/KebaStateTransformer.ts"],
  "sourcesContent": ["'use strict';\n\ntype StateNative = {\n    name: string;\n    type: 'numeric' | 'bool' | 'enum' | 'text';\n};\n\ntype StateCommon = {\n    name: string;\n    type: 'number' | 'boolean' | 'string';\n    role: string;\n    read: boolean;\n    write: boolean;\n    unit?: string;\n    states?: Record<number, string>;\n    min?: number;\n    max?: number;\n};\n\ntype StateConfiguration = {\n    type: string;\n    common: StateCommon;\n    native: StateNative;\n};\n\n\nexport default class KebaStateTransformer {\n\n    public constructor() {\n    }\n\n    public transformNameToId(name: string): string {\n        const regex = /\\[(\\d+)]\\./g;\n        return name.replace(regex, '.$1.');\n    }\n\n    public transformVarToSate(name:string, readWriteVar: any): StateConfiguration {\n\n        const typeMapping = {\n            'numeric': 'number',\n            'bool': 'boolean',\n            'enum': 'string',\n            'text': 'string',\n        };\n\n        let descriptiveName = readWriteVar.name;\n        if (readWriteVar.attributes && readWriteVar.attributes['longText']) {\n            descriptiveName = readWriteVar.attributes['longText'];\n        }\n        const common: StateCommon = {\n            name: descriptiveName,\n            type: typeMapping[readWriteVar.type],\n            role: 'value', // https://www.iobroker.net/#de/documentation/basics/roles.md\n            read: true,\n            write: readWriteVar.writable,\n        };\n        if (readWriteVar.unit) {\n            common.unit = readWriteVar.unit;\n        }\n        if (readWriteVar.formats) {\n            common.states = {};\n            for (let i = 0; i < readWriteVar.formats.length; i++) {\n                common.states[i] = readWriteVar.formats[i] || `UNDEFINED (${i})`;\n            }\n        }\n        if (readWriteVar.attributes) {\n            if (readWriteVar.attributes['upperLimit']) {\n                common.max = parseInt(readWriteVar.attributes['upperLimit']);\n            }\n            if (readWriteVar.attributes['lowerLimit']) {\n                common.min = parseInt(readWriteVar.attributes['lowerLimit']);\n            }\n        }\n        return {\n            type: 'state',\n            common,\n            native: {\n                name: name,\n                type: readWriteVar.type,\n            },\n        };\n    }\n\n\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA,MAAO,qBAAmC;AAAA,EAE/B,cAAc;AAAA,EACrB;AAAA,EAEO,kBAAkB,MAAsB;AAC3C,UAAM,QAAQ;AACd,WAAO,KAAK,QAAQ,OAAO,MAAM;AAAA,EACrC;AAAA,EAEO,mBAAmB,MAAa,cAAuC;AAE1E,UAAM,cAAc;AAAA,MAChB,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,IACZ;AAEA,QAAI,kBAAkB,aAAa;AACnC,QAAI,aAAa,cAAc,aAAa,WAAW,UAAU,GAAG;AAChE,wBAAkB,aAAa,WAAW,UAAU;AAAA,IACxD;AACA,UAAM,SAAsB;AAAA,MACxB,MAAM;AAAA,MACN,MAAM,YAAY,aAAa,IAAI;AAAA,MACnC,MAAM;AAAA;AAAA,MACN,MAAM;AAAA,MACN,OAAO,aAAa;AAAA,IACxB;AACA,QAAI,aAAa,MAAM;AACnB,aAAO,OAAO,aAAa;AAAA,IAC/B;AACA,QAAI,aAAa,SAAS;AACtB,aAAO,SAAS,CAAC;AACjB,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,QAAQ,KAAK;AAClD,eAAO,OAAO,CAAC,IAAI,aAAa,QAAQ,CAAC,KAAK,cAAc,CAAC;AAAA,MACjE;AAAA,IACJ;AACA,QAAI,aAAa,YAAY;AACzB,UAAI,aAAa,WAAW,YAAY,GAAG;AACvC,eAAO,MAAM,SAAS,aAAa,WAAW,YAAY,CAAC;AAAA,MAC/D;AACA,UAAI,aAAa,WAAW,YAAY,GAAG;AACvC,eAAO,MAAM,SAAS,aAAa,WAAW,YAAY,CAAC;AAAA,MAC/D;AAAA,IACJ;AACA,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA,QAAQ;AAAA,QACJ;AAAA,QACA,MAAM,aAAa;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAGJ;",
  "names": []
}
