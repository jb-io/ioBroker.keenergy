{
  "version": 3,
  "sources": ["../../src/lib/conditionChecker.ts"],
  "sourcesContent": ["'use strict';\n\nimport globalUtils from \"./globalUtils\";\n\ntype ValueType = string|number|boolean;\ntype CompareFunction = (value: ValueType) => boolean;\n\nconst getCompareFunction = (expression: string|null): CompareFunction => {\n    if (!expression) {\n        return (value: ValueType): boolean => {\n            if (typeof value === 'boolean') {\n                return value;\n            }\n            if (typeof value === 'number') {\n                return value > 0;\n            }\n            globalUtils.log.warn(`Could not interpret ${value} as boolean value!`);\n            return false;\n        };\n    }\n    const alwaysFalse = () => false;\n\n    // (val=0)|(val=1)\n    const orExpression = expression.match(/^(.+)\\|(.+)$/);\n    if (orExpression) {\n        return (value) => getCompareFunction(orExpression[1])(value) || getCompareFunction(orExpression[2])(value)\n    }\n\n    // (val=2)\n    const bracedExpression = expression.match(/^\\((.+)\\)$/);\n    if (bracedExpression) {\n        return (value) => getCompareFunction(bracedExpression[1])(value);\n    }\n\n    if (expression.toLowerCase() === 'false') {\n        return (value) => value === false\n    }\n\n    if (expression.toLowerCase() === 'true') {\n        return (value) => value === true\n    }\n\n    if (expression.match(/^-?\\d+$/)) {\n        return (value) => value === parseInt(expression)\n    }\n\n    const mathExpression = expression.match(/^(val=|!=|>|<)(-?\\d+)$/);\n    if (mathExpression) {\n        const operator = mathExpression[1];\n        const compareValue = parseInt(mathExpression[2]);\n        switch (operator) {\n            case 'val=':\n                return (value) => value === compareValue\n            case '!=':\n                return (value) => value !== compareValue\n            case '>':\n                return (value) => (value as number) > compareValue\n            case '<':\n                return (value) => (value as number) < compareValue\n            default:\n                globalUtils.log.warn(`Could not interpret ${operator} as operator!`);\n                return alwaysFalse;\n        }\n    }\n\n    globalUtils.log.warn(`Could not interpret ${expression} as expression!`);\n    return alwaysFalse;\n}\n\nconst checkCondition = (value: ValueType, expression: string|null = null): boolean => {\n    return getCompareFunction(expression)(value);\n}\n\nexport default checkCondition;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,yBAAwB;AAKxB,MAAM,qBAAqB,CAAC,eAA6C;AACrE,MAAI,CAAC,YAAY;AACb,WAAO,CAAC,UAA8B;AAClC,UAAI,OAAO,UAAU,WAAW;AAC5B,eAAO;AAAA,MACX;AACA,UAAI,OAAO,UAAU,UAAU;AAC3B,eAAO,QAAQ;AAAA,MACnB;AACA,yBAAAA,QAAY,IAAI,KAAK,uBAAuB,KAAK,oBAAoB;AACrE,aAAO;AAAA,IACX;AAAA,EACJ;AACA,QAAM,cAAc,MAAM;AAG1B,QAAM,eAAe,WAAW,MAAM,cAAc;AACpD,MAAI,cAAc;AACd,WAAO,CAAC,UAAU,mBAAmB,aAAa,CAAC,CAAC,EAAE,KAAK,KAAK,mBAAmB,aAAa,CAAC,CAAC,EAAE,KAAK;AAAA,EAC7G;AAGA,QAAM,mBAAmB,WAAW,MAAM,YAAY;AACtD,MAAI,kBAAkB;AAClB,WAAO,CAAC,UAAU,mBAAmB,iBAAiB,CAAC,CAAC,EAAE,KAAK;AAAA,EACnE;AAEA,MAAI,WAAW,YAAY,MAAM,SAAS;AACtC,WAAO,CAAC,UAAU,UAAU;AAAA,EAChC;AAEA,MAAI,WAAW,YAAY,MAAM,QAAQ;AACrC,WAAO,CAAC,UAAU,UAAU;AAAA,EAChC;AAEA,MAAI,WAAW,MAAM,SAAS,GAAG;AAC7B,WAAO,CAAC,UAAU,UAAU,SAAS,UAAU;AAAA,EACnD;AAEA,QAAM,iBAAiB,WAAW,MAAM,wBAAwB;AAChE,MAAI,gBAAgB;AAChB,UAAM,WAAW,eAAe,CAAC;AACjC,UAAM,eAAe,SAAS,eAAe,CAAC,CAAC;AAC/C,YAAQ,UAAU;AAAA,MACd,KAAK;AACD,eAAO,CAAC,UAAU,UAAU;AAAA,MAChC,KAAK;AACD,eAAO,CAAC,UAAU,UAAU;AAAA,MAChC,KAAK;AACD,eAAO,CAAC,UAAW,QAAmB;AAAA,MAC1C,KAAK;AACD,eAAO,CAAC,UAAW,QAAmB;AAAA,MAC1C;AACI,2BAAAA,QAAY,IAAI,KAAK,uBAAuB,QAAQ,eAAe;AACnE,eAAO;AAAA,IACf;AAAA,EACJ;AAEA,qBAAAA,QAAY,IAAI,KAAK,uBAAuB,UAAU,iBAAiB;AACvE,SAAO;AACX;AAEA,MAAM,iBAAiB,CAAC,OAAkB,aAA0B,SAAkB;AAClF,SAAO,mBAAmB,UAAU,EAAE,KAAK;AAC/C;AAEA,IAAO,2BAAQ;",
  "names": ["globalUtils"]
}
