{
  "version": 3,
  "sources": ["../../src/lib/Keba.ts"],
  "sourcesContent": ["'use strict';\n\nimport globalUtils from './globalUtils';\nimport KebaClient, {WriteVarsRequest} from './KebaClient';\nimport MaskTreeParser from './MaskTreeParser';\n\ntype ReadWriteVarsAttribute = {\n    formatId: string;\n    longText: string;\n};\n\ntype ReadWriteVarsResponse = {\n    name: string;\n    value: string;\n    attributes?: ReadWriteVarsAttribute;\n};\n\ntype ReadWriteVar = {\n    name: string;\n    type: 'text' | 'numeric' | 'enum' | 'bool';\n    writable: boolean;\n    observe?: boolean;\n};\n\ntype SystemUnit = \"ISO\" | \"imperial\";\ntype SystemLanguageCode = \"de\" | \"en\" | \"fr\";\n\nclass Keba {\n    private kebaClient: KebaClient;\n    private _languageCode?: SystemLanguageCode;\n    private _systemUnit?: SystemUnit;\n    private _readAllUnits?: Record<string, string>;\n    private _readAllFormats?: Record<string, string[]>;\n    private _readMaskTree?: string;\n    private _readWriteVars?: Record<string, ReadWriteVar>;\n\n    constructor() {\n        this.kebaClient = new KebaClient();\n    }\n\n    /**\n     * @returns {Promise<boolean>}\n     */\n    async checkConnection(): Promise<boolean> {\n        const host = globalUtils.config.host;\n        if (await this.kebaClient.getDateTime()) {\n            globalUtils.log.debug(`Connection established to ${host}`);\n            return true;\n        }\n        globalUtils.log.error(`Errors while trying to connect to ${host}`);\n        return false;\n    }\n\n    /**\n     * @returns {Promise<SystemLanguageCode>}\n     */\n    async getLanguageCode(): Promise<SystemLanguageCode> {\n        if (!this._languageCode) {\n            if (globalUtils.config.languageCode === 'auto') {\n                this._languageCode = (await this.kebaClient.getLanguageCode()) || 'en';\n            } else {\n                this._languageCode = globalUtils.config.languageCode as SystemLanguageCode;\n            }\n        }\n        return this._languageCode;\n    }\n\n    /**\n     * @returns {Promise<SystemUnit>}\n     */\n    async getSystemUnit(): Promise<SystemUnit> {\n        if (!this._systemUnit) {\n            if (globalUtils.config.systemUnit === 'auto') {\n                this._systemUnit = await this.kebaClient.getSystemUnit() as SystemUnit;\n            } else {\n                this._systemUnit = globalUtils.config.systemUnit as SystemUnit;\n            }\n        }\n        return this._systemUnit;\n    }\n\n    async readAllUnits(): Promise<Record<string, string>> {\n        if (!this._readAllUnits) {\n            const systemUnit = await this.getSystemUnit();\n            const unitProperty = systemUnit.toLowerCase() === 'imperial' ? 'textImperial' : 'textIso';\n\n            this._readAllUnits = {};\n            const units = await this.kebaClient.readAllUnits(await this.getLanguageCode());\n            for (const unit of units) {\n                const identifierProperty = 'unitId';\n                if (unit[identifierProperty] && unit[unitProperty]) {\n                    this._readAllUnits[unit[identifierProperty]] = unit[unitProperty];\n                }\n            }\n        }\n        return this._readAllUnits;\n    }\n\n    async readAllFormats(): Promise<Record<string, string[]>> {\n        if (!this._readAllFormats) {\n            this._readAllFormats = {};\n            const formats = await this.kebaClient.readAllFormats(await this.getLanguageCode());\n            for (const format of formats) {\n                const identifierProperty = 'formatId';\n                const valueProperty = 'formatTexts';\n                if (format[identifierProperty] && format[valueProperty]) {\n                    this._readAllFormats[format[identifierProperty]] = format[valueProperty].split('|');\n                }\n            }\n        }\n        return this._readAllFormats;\n    }\n\n    async readMaskTreeGetContent(): Promise<string> {\n        if (!this._readMaskTree) {\n            this._readMaskTree = await this.kebaClient.readMaskTreeGetContent();\n        }\n        return this._readMaskTree;\n    }\n\n    async readVar(id: string, withAttributes: boolean = false): Promise<ReadWriteVarsResponse> {\n        return (await this.readVars([id], withAttributes))[0];\n    }\n\n    async readVars(ids: string[], withAttributes: boolean = false): Promise<ReadWriteVarsResponse[]> {\n        const blockSize = 50;\n        const postData: { name: string; attr?: '1' | '0' }[] = [];\n        for (const id of ids) {\n            const item: { name: string; attr?: '1' | '0' } = { name: id };\n            if (withAttributes) {\n                item.attr = '1';\n            }\n            postData.push(item);\n        }\n        const result: ReadWriteVarsResponse[] = [];\n        const languageCode = await this.getLanguageCode();\n        while (postData.length > 0) {\n            const postDataSub = postData.splice(0, blockSize);\n            result.push(...(await this.kebaClient.readVars(languageCode, postDataSub)));\n        }\n        return result;\n    }\n\n    async writeVar(id: string, value: string): Promise<boolean> {\n        return await this.writeVars({ [id]: value });\n    }\n\n    async writeVars(values: Record<string, string>): Promise<boolean> {\n        const data: WriteVarsRequest[] = [];\n        for (const id in values) {\n            data.push({ name: id, value: values[id] });\n        }\n        return await this.kebaClient.writeVars(data);\n    }\n\n    async getReadWriteVars(): Promise<Record<string, ReadWriteVar>> {\n        if (!this._readWriteVars) {\n            const parser = new MaskTreeParser(this);\n            this._readWriteVars = await parser.getVarsFromMaskTree();\n        }\n        return this._readWriteVars;\n    }\n}\n\nexport default Keba;\n"],
  "mappings": "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",
  "names": ["KebaClient", "globalUtils", "MaskTreeParser"]
}
