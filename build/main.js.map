{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.3\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\n// Load your modules here:\nimport KebaMiddleware from './lib/KebaMiddleware';\nimport globalUtils from './lib/globalUtils';\n\nclass Keenergy extends utils.Adapter {\n\n\n    private _periodically: ReturnType<typeof this.setInterval> = null;\n    private _kebaMiddleware: null|KebaMiddleware = null;\n    private _stateIds: Array<string> = [];\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'keenergy',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        // this.on('objectChange', this.onObjectChange.bind(this));\n        // this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n\n        this._periodically = null;\n        this._kebaMiddleware = null;\n        this._stateIds = [];\n    }\n\n    init() {\n        // Initialize your adapter here\n        globalUtils.adapter = this;\n\n        // const config = this.config;\n        //\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n        // this.config:\n        // this.log.debug('config host: ' + config.host);\n        // this.log.debug('config updateInterval: ' + config.updateInterval);\n    }\n\n    public get kebaMiddleware(): KebaMiddleware {\n        if (!this._kebaMiddleware) {\n            this._kebaMiddleware = new KebaMiddleware();\n        }\n        return this._kebaMiddleware;\n    }\n\n    setConnectionState(state: boolean): void {\n        this.setState('info.connection', state, true);\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n\n        // Reset the connection indicator during startup\n        this.setConnectionState(false);\n\n        this.init();\n\n        if (await this.kebaMiddleware.keba.checkConnection()) {\n            this.setConnectionState(true);\n\n            await this.createStates();\n\n            this.registerPeriodicalCall();\n        }\n\n        /*\n        For every state in the system there has to be also an object of type state\n        Here a simple template for a boolean variable named \"testVariable\"\n        Because every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\n        */\n\n        // for (const name in readWriteVars) {\n        //     await this.createKebaState(name);\n        // }\n    }\n\n    private async createStates() {\n\n        if (this.config.reloadAllStates) {\n            const existingStateIds = await this.getExistingStateIds();\n            for (const id in existingStateIds) {\n                await this.delStateAsync(this.removeNamespaceFromStateId(id));\n            }\n        }\n\n        const stateConfigurations = await this.kebaMiddleware.getStateConfigurations();\n        for (const id in stateConfigurations) {\n            const stateConfiguration = stateConfigurations[id] as ioBroker.SettableObject;\n            // noinspection JSCheckFunctionSignatures\n            await this.setObjectNotExistsAsync(id, stateConfiguration).then(() => {\n                this._stateIds.push(id);\n            });\n\n\n            if (stateConfiguration.common && (stateConfiguration.common as ioBroker.StateCommon).write) {\n                // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n                this.subscribeStates(id);\n                // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n                // this.subscribeStates('lights.*');\n                // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n                // this.subscribeStates('*');\n            }\n        }\n    }\n\n    private registerPeriodicalCall() {\n        const updateInterval = parseInt(this.config.updateInterval) * 1000;\n        this._periodically = this.setInterval(this.onPeriodically.bind(this), updateInterval);\n    }\n\n    private async onPeriodically() {\n        if (await this.kebaMiddleware.keba.checkConnection()) {\n\n            const states = await this.kebaMiddleware.readStates(this._stateIds);\n            const existingStateIds = await this.getExistingStateIds();\n\n            for (const id in states) {\n                const val = states[id];\n                if (!existingStateIds.includes(id)) {\n                    const stateConfiguration = await this.kebaMiddleware.getStateConfiguration(id) as ioBroker.SettableObject;\n                    // noinspection JSCheckFunctionSignatures\n                    await this.setObjectNotExistsAsync(id, stateConfiguration);\n                }\n                await this.setState(id, val, true);\n            }\n\n        }\n    }\n\n    async getExistingStateIds() {\n        return Object.keys(await this.getStatesAsync('APPL.*')).map((id) => this.removeNamespaceFromStateId(id));\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            if (this._periodically) {\n                this.clearInterval(this._periodically);\n            }\n\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateDeleted(id: string): Promise<void> {\n        this.log.warn(`state ${id} deleted`);\n        this.log.debug(`recreate state ${id} in order to avoid errors.`);\n        const stateConfiguration = await this.kebaMiddleware.getStateConfiguration(id) as ioBroker.SettableObject;\n        // noinspection JSCheckFunctionSignatures\n        await this.setObjectNotExistsAsync(id, stateConfiguration);\n        const val = await this.kebaMiddleware.readState(id);\n        await this.setState(id, val, true );\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChangeExternal(id: string, state: ioBroker.State): Promise<void> {\n        try {\n            if (null !== state.val) {\n                const newVal = await this.kebaMiddleware.writeState(id, state.val);\n                this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack}, by = ${state.from})`);\n                await this.setState(id, newVal, true);\n            } else {\n                this.log.warn(`Ignoring state ${id} changed: ${state.val} (ack = ${state.ack}, by = ${state.from}) because value must not be null.`);\n            }\n        } catch (e) {\n            this.log.warn(`Ignoring state ${id} changed: ${state.val} (ack = ${state.ack}, by = ${state.from}) because var is not writable.`);\n        }\n    }\n\n    protected removeNamespaceFromStateId(id: string): string {\n        if (id.search(this.namespace) === 0) {\n            id = id.substring(this.namespace.length + 1);\n        }\n        return id;\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     * @param {string} id\n     * @param {ioBroker.State | null | undefined} state\n     */\n    private async onStateChange(id: string, state: ioBroker.State|null|undefined): Promise<void> {\n        id = this.removeNamespaceFromStateId(id);\n\n        if (!state) {\n            // The state was deleted\n            await this.onStateDeleted(id);\n            return;\n        }\n        if (!state.ack) {\n            // The state was changed externally\n            await this.onStateChangeExternal(id, state);\n        }\n    }\n\n\n\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Keenergy(options);\n} else {\n    // otherwise start the instance directly\n    new Keenergy();\n}\n"],
  "mappings": "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",
  "names": ["globalUtils", "KebaMiddleware"]
}
